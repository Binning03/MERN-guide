async / await / .then / promise / json / try / catch 에 대한 이해 필요
useEffect, useCallback, useRef, useReducer 등 hook 이해 필요
!!(thing) -> if thing exist -> true, else -> false
id data비교할 때 .toString() 고려

section1

MERN
MongoDB
Express
React
NodeJS

section2

Client(react)와 Server(nodejs, express)가 어떻게 통신하냐
Client와 Server가 HTTP요청 주고받는 방식으로 통신함
AJAX를 통해 보이지 않는 곳에서 처리함
Client의 JS에서 트리거되어 Server에서 보통 JSON형식으로 된 데이터로 응답을 줌
Database Server(mongodb)는 영구 데이터 저장소로 사용됨

Server가 Db Server와 통신함 / Client는 Db Server와 통신X
Db Server는 Db에 대한 자격 증명을 통해 접근하기 때문에 Server에서만 통신

Frontend
React SPA - 화면 구성
-> Routes (react-router-dom) - Route Config, Page Components
   State Management (Hooks, Redux) - Redux Logic, React Hooks, Custon Hooks
   Components + Styling (CSS) - Utility, UI Components
   
Backend
==API
- REST API - Variable URLs + Variable Http Verbs for different actions
- GraphQL API - One URL + One Http Verb accepts query commands 
  (query language for different actions)
-> 두 API는 호출을 보낼 때 따르는 포멧에서 차이를 보임

Node와 React 연결하기
1. Server Hosts Node API + React SPA
2. Two Separated Servers (많은 요청받기 좋음)
In both Cases Logically Separated Apps(SPA + API) / DB Servaer 따로
3. Server rendered Pages (via EJS, Pug...) (deprecated)

simple-mern-project
backend의 data를 frontend에서 가져옴

section3

Planning a MERN Project
1. Come up with an idea
2. Create a design/sketch (frontend design with design tool)
3. Plan data models (what entity needs, what data should be moved to frontend)
4. Plan API endpoints and SPA pages (send data with API, page Router)

section4

자식과 부모 component통신
부모 -> 자식 : props로 data전달
             자식component에서 부모data사용
자식 -> 부모 : props로 eventHandler(ex: stateFunc)전달
             자식component에서 자식data가지고 eventHandler사용

section5

stateful component - presentational(stateless) component

component의 여는 태그와 닫는 태그 사이에 입력한 것은 props.children으로 전달됨
props.children을 사용하면, 코드의 재사용성을 향상하며 JSX 요소를 좀 더 유연하고 밀접하게 다룰 수 있습니다.

React portal
component를 본래 렌더링되는 위치 외에서도 구현하거나 렌더링할 수 있게함
createPortal을 사용하면 자식을 원하는 위치에 렌더링 시킬 수 있습니다. 
여기서 자식은 react로 렌더링 할 수 있는 모든 것을 말합니다.
index.html에 추가하여 사용
(생겼다 없어지는 요소 만들때 사용 ex: 모달, 사이드바...)

react transition group
애니메이션 효과를 주는 라이브러리

google maps platform
AIzaSyDUwXLgLeeKuh6ZGfp7BxBBFk_GWiY8yf4

Custom Hook
기존 react hook들을 사용하여 custom hook을 만들어 사용
https://legacy.reactjs.org/docs/hooks-custom.html
중복되는 내용들을 hook으로 만들어 사용

react context (useContext)
context는 프로퍼티 없이 애플리케이션의 어느 컴포넌트에든 데이터를 보낼 수 있음
애플리케이션 전반에 영향을 주는 데이터를 사용할 때 유용함(ex. login)

section6

<package.json>
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "start": "nodemon app.js"
  } -> npm start

body-parser
body-parser는 Node.JS의 모듈 중 하나로, 클라이언트가 보내는 
Request Data의 Body로부터 파라미터를 편리하게 추출 할 수 있음
-> req.body 필드를 생성해줌
express에 내장되어 있어 아래 명령어로 퉁칠 수 있음
express.urlencoded() or express.json()
.urlencoded()은 x-www-form-urlencoded형태의 데이터를
.json()은 JSON형태의 데이터를 해석해줌

section7

route의 순서
: params 포함된 route 잘 고려해서 route 순서 조정
(: params 포함된 route가 뒤로)

error handler
<app.js>
  app.use((error, req, res, next) => {
    if (res.headerSent) {
      return next(error);
    }
    res.status(error.code || 500);
    res.json({message: error.message || 'An unkown error occured!'});
  });
<route>
  if(error exist) {
    const error = new Error('Could not find a place for the provided id.');
    error.code = 404;
    return next(error);
  } 
  
controller
route에 있는 코드 줄이기

잘못된 route 막기
app.use((req, res, next) => {
  const error = new HttpError('Could not find this route.', 404);
  throw(error);
});

express-validator
backend에서 req.body의 유효성검사

axios
frontend에서 backend로 http요청을 발신하는데 쓰임
node서버에서 다른 API로 요청을 보낼 때도 사용됨

section8

database를 react(frontend)에 연결하면 강력한 인증, 보안이 불가능함
fontend코드는 브라우저에서 실행되기 때문에 누구나 코드에 엑세스 할 수 있어
자격증명이 털릴 수 있음

mongo
qbmDpzPjvh4jDJJf
mongodb+srv://<userName>:<password>@cluster0.orgwzio.mongodb.net/
<collectionName>?retryWrites=true&w=majority&appName=Cluster0
<mongo code>
const MongoClient = require('mongodb').MongoClient;

const url =
  'mongodb+srv://manu:KyOP1JrHoErqQILt@cluster0-g8eu9.mongodb.net/products_test?retryWrites=true&w=majority';

const createProduct = async (req, res, next) => {
  const newProduct = {
    name: req.body.name,
    price: req.body.price
  };
  const client = new MongoClient(url);

  try {
    await client.connect();
    const db = client.db();
    const result = db.collection('products').insertOne(newProduct);
  } catch (error) {
    return res.json({message: 'Could not store data.'});
  };
  client.close();

  res.json(newProduct);
};

const getProducts = async (req, res, next) => {
  const client = new MongoClient(url);

  let products;

  try {
    await client.connect();
    const db = client.db();
    products = await db.collection('products').find().toArray();
  } catch (error) {
    return res.json({message: 'Could not retrieve products.'});
  };
  client.close();

  res.json(products);
};

mongoose
schema를 사용하여 database의 구조를 정의함
<with mongoose code>
const mongoose = require('mongoose');

const productSchema = new mongoose.Schema({
    name: { type: String, required: true },
    price: { type: Number, required: true }
});

module.exports = mongoose.model('Product', productSchema);

↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓

const mongoose = require('mongoose');

const Product = require('./models/product');

mongoose.connect(
  'mongodb+srv://manu:KyOP1JrHoErqQILt@cluster0-g8eu9.mongodb.net/products_test?retryWrites=true&w=majority'
).then(() => {
    console.log('Connected to database!')
}).catch(() => {
    console.log('Connection failed!')
});

const createProduct = async (req, res, next) => {
  const createdProduct = new Product({
    name: req.body.name,
    price: req.body.price
  });
  
  const result = await createdProduct.save();
  res.json(result);
};

const getProducts = async (req, res, next) => {
  const products = await Product.find().exec();
  res.json(products);
}

section09

data간의 관계 설정
creator: { type: mongoose.Types.ObjectId, required: true, ref: 'User'}
places: [
  { type: mongoose.Types.ObjectId, required: true, ref: 'Place'}
]

transaction
여러개의 작업을 개별적으로 수행하여 모든 작업이 정상적으로 끝났을 때
최종적으로 커밋할 수 있게 해줌
(연쇄적인 작업에서 하나라도 잘못되면 이전 작업의 커밋을 막을 수 있음)
  try {
    const sess = await mongoose.startSession();
    sess.startTransaction();
    await createdPlace.save({session: sess});
    user.places.push(createdPlace);
    await user.save({session: sess});
    await sess.commitTransaction();
  } catch(err) {
    const error = new HttpError('Creating place failed.', 500);
    return next(error);
  }
  
section10

frontend-backend 연결 *****

fetch로 소통을 함
docs: https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API
try {
  const response = await fetch('https://backenddemo.run.goorm.io/api/users/signup', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      name: formState.inputs.name.value,
      email: formState.inputs.email.value,
      password: formState.inputs.password.value
    })
  });  
  
  const responseData = await response.json(); 
  //createdUser data in backend
} catch()
        
cors error
https://selfish-developer.com/entry/%EC%A7%80%EA%B8%8B%EC%A7%80%EA%B8%8B%ED%95%9C-CORS-error-%EC%9D%B4%EC%A0%9C-%EC%A0%9C%EB%8C%80%EB%A1%9C-%EA%B3%B5%EB%B6%80%ED%95%B4%EB%B3%B4%EC%9E%90
프론트엔드 앱 내부에서 API로 통신하는 것을 구축할 때 보이는 오류
서버의 리소스는 오직 같은 서버에서 오는 요청에 의해서 공유되는 원칙
(다른 도메인의 frontend, backend 소통이 불가)
-> backend의 app.js에 아래 코드 추가
app.use((req, res, next) => {
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader(
    'Access-Control-Allow-Headers',
    'Origin, X-Requested-With, Content-Type, Accept, Authorization'
  );
  res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PATCH, DELETE');
  next();
});
-> frontend에서 data보낼때 아래코드로 전달
{
  'Context-Type': 'application/json'
}

frontend에서 loading, error 처리
const [isLoading, setIsLoading] = useState(false);
const [error, setError] = useState(false);
-> isLoading에 따라 로딩창 띄우고
   error에 따라 에러창 띄우기
if (!response.ok) {
  throw new Error(responseData.message);
} (.ok: code 2nn일때 true 반환)
  
get요청으로 정보 가져오기
  useEffect(() => {
    const sendRequest = async () => {
      try {
        const response = await fetch('https://backenddemo.run.goorm.io/api/users');
        const responseData = await response.json();
        setLoadedUsers(responseData.users);
      } catch ()
    };
    sendRequest();
  }, []);

useEffect, useCallback...을 이용하여
컴포넌트가 재실행/새로고침할 때마다 훅이 재실행 되는 것을 막기
(잘 모르겠음)

section11

image upload

multer
text data만 다룰 수 있는 json과 달리 text, file, binary data를 다룰 수 있음
<file-upload middleware with multer>
const MIME_TYPE_MAP = {
  'image/png': 'png',
  'image/jpeg': 'jpeg',
  'image/jpg': 'jpg'
};

const fileUpload = multer({
  limits: 500000,
  storage: multer.diskStorage({
    destination: (req, file, cb) => {
      cb(null, 'uploads/images');
    },
    filename: (req, file, cb) => {
      const ext = MIME_TYPE_MAP[file.mimetype];
      cb(null, uuid() + '.' + ext);
    }
  }),
  fileFilter: (req, file, cb) => {
    const isValid = !!MIME_TYPE_MAP[file.mimetype];
    let error = isValid ? null : new Error('Invalid mime type!');
    cb(error, isValid);
  }
});

backend frontend 사이 imageFile 주고받기
원래 JSON.stringify로 전달하던 형식을 바꿔야함
<before>
        const responseData = await sendRequest(
          'https://backenddemo.run.goorm.io/api/users/signup',
          'POST',
          JSON.stringify({
            name: formState.inputs.name.value,
            email: formState.inputs.email.value,
            password: formState.inputs.password.value,
          }),
          {
            'Content-Type': 'application/json',
          }
        );
<after>
        const formData = new FormData();
        formData.append('email', formState.inputs.email.value);
        formData.append('name', formState.inputs.name.value);
        formData.append('password', formState.inputs.password.value);
        formData.append('image', formState.inputs.image.value);
        const responseData = await sendRequest(
          'https://backenddemo.run.goorm.io/api/users/signup',
          'POST',
          formData
        );

image를 backendURL로 전달할 때 정적으로 전달해야됨
app.use('/uploads/images', express.static(path.join('uploads', 'image')));

section12

인증기능
server가 token(cookie, localStorage)을 생성하고 토큰을 SPA에서 요청하는
req에 첨부되면 서버가 토큰을 검사하여 인증을 진행함

jsonwebtoken
싱글 페이지 애플리케이션(SPA)에서 인증을 구현하는 가장 일반적인 방법

token 생성
  let token;
  try {
    token = jwt.sign(
      { userId: createdUser.id, 
      email: createdUser.email }, 
      'supersecret', 
      { expiresIn: '1h'}
    );
  } catch
-> json에 token첨부하여 send

middleware를 통해 token 확인
  try {
    const token = req.headers.authorization.split(' ')[1]; //Authorization: 'Bearer TOKEN'
    if(!token) {
      throw new Error('Authentication failed!');
    }
    const decodedToken = jwt.verify(token, 'supersecret');
    req.userData = {userId: decodedToken.userId}; 
    //token으로 인해 req.userData로 userId 접근가능
    next();
  } catch (err) {
    const error = new HttpError('Authentication failed!', 401);
    return next(error);
  }
-> frontend에서 req를 보낼 때 req.headers에 token을 함께 보내면
   backend에서 middleware를 통해 인증
    {
      Authorization: 'Bearer ' + auth.token
    }
    
권한기능
frontend/backend 두 곳에서 각각 id확인절차 필요

login 유지하기
새로고침하면 react앱이 재시작되기에 token으로는 login 유지가 안됨
-> cookies or local storage 사용
  localStorage.setItem(
    'userData', 
    JSON.stringify({userId: uid, token: token})
  );
(login할 때 localStorage에 정보 추가)
  useEffect(() => {
    const storedData = JSON.parse(localStorage.getItem('userData'));
    if(storedData && storedData.token) {
      login(storedData.userId, storedData.token);
    }
  }, [login]);
(새로고침 시 localStorage에서 정보 가져와서 자동 로그인)
  localStorage.removeItem('userData');
(logout할 때 localStorage 삭제)

토큰 만료시간에 따른 자동 logout
  useEffect(() => {
    if(token && tokenExpirationDate) {
      const remainingTime = tokenExpirationDate.getTime() - new Date().getTime();
      logoutTimer = setTimeout(logout, remainingTime);
    } else {
      clearTimeout(logoutTimer);
    }
  }, [token, logout, tokenExpirationDate]);
(token 만료시간 가지고 있다가 setTimeout설정해서 자동 logout)
(login 코드 부분에 tokenExpirationDate 관련 코드 추가)

section13

애플리케이션 배포
1. test your code
2. swap URLs, Credentials for Production-ready Ones
  (Consider using Envirionment Variables)
3. Build, Deploy
4. Test Deployed Application

backend에서 .env를 nodemon.json으로
{
  "env": {
    "DB_USER": "new-user",
    "DB_PASSWORD": "qbmDpzPjvh4jDJJf",
    "DB_NAME": "mern",
    "GOOGLE_API_KEY": "AIzaSyDUwXLgLeeKuh6ZGfp7BxBBFk_GWiY8yf4",
    "JWT_KEY": "supersecret"
  }
}

react에서 .env쓸 때
환경변수는 REACT_APP로 시작해야 함
REACT_APP_GOOGLE_API_KEY=AIzaSyDUwXLgLeeKuh6ZGfp7BxBBFk_GWiY8yf4
REACT_APP_BACKEND_URL=https://backenddemo.run.goorm.io/api
REACT_APP_ASSET_URL=https://backenddemo.run.goorm.io

API_KEY나 Database를 새로 만들어 production용/개발용으로 사용
.env.production 빌드시 쓰는 env 파일
-> 배포된 api
.env.development 개발할 때 쓰는 env 파일
-> localhost:8000 

React 코드분할
앱을 “지연 로딩” 하게 도와주고 앱 사용자에게 획기적인 성능 향상을 하게 함
import Users from './users/pages/Users'; (in app.js route)
-> const Users = React.lazy(() => import('./users/pages/Users'));
  + <Suspense></Suspense>

npm run build
코드를 최적화하여 build해줌

배포
1. Deploy Two Separated Apps (React App / Node REST API)
Static Host / Node.js Host
CORS Headers required
2. Deploy One Combined App (Node REST API which renders the React App)
Node.js Host
CORS Headers are not required

